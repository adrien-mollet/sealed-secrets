# Cryptographic documentation

## Protocols and cryptographic tools used

Sealed-secrets uses the following protocols for the secret management:

- **AES-256-GCM** with a randomly generated single-use 32 bytes session key. Since the key is single-use, we do not use any nonce. The key is used to encrypt the secret, ensuring its confidentiality and integrity.
- **RSA-OAEP**, with **SHA-256**. It is used to assure the confidentiality of the AES-256-GCM session key, following the *key encapsulation mechanism*.
- **X509** certificates are used to manage RSA public keys. This public key contained in the certificate can be used to encrypt AES-256-GCM session key.

Certificates generated by the sealed secrets controller are renewed every 30 days and have a 10 years validity span.

## Entropy considerations

The golang API used for the entropy is `crypto/rand`. The following description can be found about the entropy generator used regarding the host system:

```
// On Linux, FreeBSD, Dragonfly and Solaris, Reader uses getrandom(2) if
// available, /dev/urandom otherwise.
// On OpenBSD and macOS, Reader uses getentropy(2).
// On other Unix-like systems, Reader reads from /dev/urandom.
// On Windows systems, Reader uses the RtlGenRandom API.
// On Wasm, Reader uses the Web Crypto API.
```

Those cryptographic APIs are known to provide a good cryptographic entropy, and are not vulnerable to cryptographic attacks unless the seed is known.

For further information about those APIs:

- [Linux/FreeBSD/Dragonfly/Solaris](https://linux.die.net/man/4/urandom)
- [OpenBSD/macOS](https://www.freebsd.org/cgi/man.cgi?query=getentropy&sektion=3&format=html)
- [Windows](https://download.microsoft.com/download/1/c/9/1c9813b8-089c-4fef-b2ad-ad80e79403ba/Whitepaper%20-%20The%20Windows%2010%20random%20number%20generation%20infrastructure.pdf)
- [WASM](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues)

## Functioning

### Public/private key pair management

The controller looks for a cluster-wide private/public key pair on startup. If no key pair is found and none is provided manually, the controller generates a new 4096 bit (by default) RSA key pair. In both cases, the key pair is persisted in a regular Secret in the same namespace as the controller.

The public key (in the form of a self-signed certificate if it was generated by the controller) should be made publicly available to anyone wanting to use SealedSecrets with this cluster.

Note that it is possible to use your own X509 certificate with the command bellow:

```
kubeseal --cert [https:/]/path/to/your-cert.pem
```

The certificate is printed to the controller log at startup and is also available via an HTTP GET request to `/v1/cert.pem` on the controller.

### Secret encryption

The secret is encrypted by AES-256-GCM with a randomly-generated single-use 32 byte session key.

The result of this operation will be called `AES encrypted data` in the next diagram, and the present step is the `1.`.

### Session key encryption

The session key used by AES-256-GCM to encrypt the Secret is encapsulated with the controller's public key using RSA-OAEP with SHA256.

The OAEP input content, called `label` in the next diagram, differs depending on the sealed secret controller scope configuration. This algorithm is only used to encrypt the AES session key.

- Default scope configuration : `label` is equal to the concatenation of the Secret's namespace and the Secret's name.
- Namespace-wide scope configuration : `label` is equal to the Secret's namespace.
- Cluster-wide scope configuration : `label` is empty.

The result of the RSA-OAEP encryption is called `RSA encrypted data` in the next diagram, and the present step is the `2.`.

### Sealed Secret storage

The final Sealed Secret data format is the following (where `||` is the concatenation operator): `size of AES encrypted key (2 bytes) || RSA encrypted data || AES encrypted data`

### Diagram to summarize

```
								Secret
                                                                   |
                                                                   │
                                                   K_s────────────►│
                                                    │              │
                                       K_pub───────►│              │
                                                    │              │ 1.
                                       label───────►│ 2.           │
                                                    │              │
                     ┌──────────────────────┬───────▼───────┬──────▼───────┐
Sealed Secret data = │size of AES encrypted │ RSA encrypted │ AES encrypted│
                     │key (2 bytes)         │ data          │ data         │
                     └──────────────────────┴───────────────┴──────────────┘

K_s = 256 bits single-use session key, used by AES-GCM
K_pub = Public key from the self-signed certificate, used by RSA-OAEP
label = Additional input for RSA-OAEP encryption.
        Content differs depending on the scope configuration:
         * Default config : label = Secret's namespace || Secret's name
         * Namespace-wide : label = Secret's namespace
         * Cluster-wide : label is empty
```

### Decryption process

The decryption is simply the inversion of the encryption.

`Size of AES encrypted key` is read and used to separate `RSA encrypted data` and `AES encrypted data` properly.

Then the private key associated with the public key (see Session key encryption) is used with the `label` to decrypt the `RSA encrypted data`, effectively retrieving the AES session key.

To end this process, the `AES encrypted data` is decrypted using the AES session key, therefore unsealing the original Secret.
